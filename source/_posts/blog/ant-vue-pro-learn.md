---
title: Ant front learn
date: 2019-07-14 00:00:00
tags: [javascript, technology]
categories: technology 技术
---

Ant Vue 实现使用总结

<!-- more -->

## 流程

1. 初步实现
2. 风格确定
3. 代码审查

## 知识补充

- Vue.prototype

当你在main.js里声明了Vue.prototype.a = 1后，因为你的每一个vue组件都是一个Vue对象的实例，所以即使你没有在组件内部使用data(){return{……}}声明a，你依然可以在组件中通过this.a来访问。
当然，你也可以在组件中添加一个变量a，这时你访问的就是你在组件中添加的a，而不再是之前在原型中添加的a了，当然你对组件的a继续修改即不会影响原型中的a和其他组建中的a，就类似于下面这段代码（Form是一个自定义对象类型，Vue也可以看作一个自定义对象类型，而每个.vue文件就是一个对象的实例）

- mock请求

mock的请求不会在浏览器被记录的，它是一种js代码控制的行为，当然不知道是不是有其它办法，总之用了mock需要调试的话，使用console
mock的初始化要先，保证被mock记录的URL都能被拦截到

## 规范

注释：

```
<!-- 用户管理视图
@author vanliuzhi
@create 2019-08-15
-->
```

```
/**
 * @description 系统管理，用户管理API
 * @author vanliuzhi
 * @create 2019-08-15
 */
```

数据相应结构：
```
{
	"message": "",
	"result": {},
	"code": 200,
	"timestamp": 
}
```

## vue-cli3.0

全新的脚手架

### vue-cli3.0 环境变量与模式

vue-cli3.0移除了配置文件目录：config和build文件夹(最外层已经没有这两个文件夹了)

总共提供了四种方式来制定环境变量：

1. 在根目录添加.env文件，配置所有情况下都会用到的配置（不知道这个存在的意义，所有的都需要的也就不需要配置了吧）。
2. 在根目录添加.env.local 文件，配置所有情况下都会用到的配置，与.env的区别是只会在本地，该文件不会被git跟踪。
3. 在根目录添加.env.[mode] 文件，配置对应某个模式下的配置,比如：.env.development来配置开发环境的配置。
4. 在根目录添加.env.[mode].local文件，配置对应某个模式下的配置,与.env.[mode]的区别也只是会在本地生效，该文件不会被git跟踪。

修改环境变量后，记得手动重启，让环境变量重新写入系统上下文

## layouts布局组件

根目录layouts文件下存放了所有布局组件，路由可以配置使用的组件，所以一些页面默认是带了布局的

- UserLayout

该组件用于`'/user'`路由下，即登录注册等

## 权限设计

RBAC设计思想

基于角色的访问控制（Role-Based Access Control）
有两种正在实践中使用的RBAC访问控制方式：隐式(模糊)的方式和显示(明确)的方式。

隐式：假如用于属于管理员，在对账户操作的时候，就去判断用于是否是管理员角色，因为在常规的认知中，管理员一般都是能操作账号的，但是实际是否分配的这样的权限是未知的，这就是隐式的，是一种假设。
显示：就是明确的权限判断

### 表结构

1. user 用户表
2. role 角色表
3. permission 权限表
4. user_role 用户和角色关联表
5. role_permission 角色和权限关联表

## main.js

程序主入口，一般会导入各种配置文件，前端的路由和后端的接口URL不是一个概念，路由的URL跳转不会去和后端交互

### permission

权限控制部分，通过路由守卫来完成，根据有无token来决定下一步。目前绝大部分项目的思路都很类似，比较的工程化，最好也参照这个流程来

1. 有

如果`to.path`是登录页面，一般跳转到首页去，否则，获取用户信息等操作

2. 无

白名单直接登录，否则跳转到登录页面，登录页面表单接受用户名和密码，调用`store`中`user`的`actions`中的`Login`，在Login中去请求真正的登录接口


