---
title: 计算机知识补充
date: 2018-10-22 00:00:00
tags: [learn, other]
categories: other
---

计算机知识补充

<!-- more -->

## 为什么不要用记事本来写代码？

可能有人会怪windows怎么那么傻，一个\n不就可以了，为什么要用\r\n呢，给我们造成了多大的麻烦。其实这也不能怪windows。使用\r\n的历史可以追溯到遥远的19世纪。 那时候发明的打字机主要结构是一个实心圆筒+排列成菊花状的字模。纸张被牢牢地固定在圆筒的表面上。当我们按下一个字母的时候，机械装置引动字模"飞"向纸张，同时圆筒前的色带升起，用力地印下去，于是纸张上面就出现一个字了。印完之后，机械装置自动地让圆筒向左移动一个字母格子，方便打印下一个字符。打完一行之后，左手边上有一个摇杆，摇一下，圆筒就可以滚动一个行距，这是换行。不过，因为打字的时候圆筒总会不断地向左移动，所以打字员还需要用力地把圆筒推回右边，这就是传说中的回车了。在计算机里常见的换行操作在打字机里需要换行+回车两个操作。自然，计算机里不用这么麻烦，不过windows喜欢看起来更兼容一点。于是换行就成了\r\n了。

## 猴子补丁

“猴子补丁”就是指，在函数或对象已经定义之后，再去改变它们的行为。

## Scale

Scale Out（也就是Scale horizontally）横向扩展，向外扩展

Scale Up（也就是Scale vertically）纵向扩展，向上扩展

无论是Scale Out，Scale Up，Scale In，实际上就是一种架构的概念，这些概念用在存储上可以，用在数据库上，网络上一样可以。

简单比喻下Scale out和Scale up，帮助我们理解：
- Scale Out，比如：我们向原有的web、邮件系统添加一个新机器。
- Scale UP，比如：我们向原有的机器添加CPU、内存。

## 斜杠与反斜杠
“\”与“/”斜杠与反斜杠，只要知道，在windows路径里面用反斜杠，其它一般都是斜杠

\ 转义，Python中加 r 不转义 r '\t' 结果是 \t

## 秒的定义

国际单位制词头经常与秒结合以做更细微的划分，例如ms（毫秒，千分之一秒）、μs（微秒，百万分之一秒）和ns（纳秒，十亿分之一秒）。虽然国际单位制词头虽然也可以用于扩增时间，例如Ks（千秒）、Ms（百万秒）和Gs（十亿秒），但实际上很少这样子使用，大家都还是习惯用60进制的分、时和24进制的日做为秒的扩充。

## csv文件

csv文件，使用逗号分隔，这种格式的文本可以导到excel

## 名词缩写

进程间通信（Inter Process Communication，IPC）

POSIX表示可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ）这个标准制定了一些通用的东西，方便大家在实现的时候做到通用性，那么移植就不会有太大的问题了

SMP：对称多处理结构，一个计算机上使用多个CPU，而内存，总线是共享的

conditional requests : 条件请求，可以改变请求的资源

Cross Origin Resource Sharing（CORS）跨域资源共享

fd(file descriptor) 文件描述符

oom (out of memory) 内存溢出 `oom killer` 这个东西会在系统内存耗尽的情况下跳出来，选择性的干掉一些进程以求释放一些内存。具体的记录日志是在/var/log/messages中，如果出现了Out of memory字样，说明系统曾经出现过OOM！

## utf-8 和 unicode
必须知道的是，utf-8是unicode的一种实现方式，比如utf-16也是。互联网多采用utf-8，之所以出现unicode的多种实现，是因为为了表数多字符的二进制，需要使用多个字节，这带来的存储的不便利（比如在Unicode中英文用一个字节就行了，汉字会占用2个或3个等，如果大家都统一成4字节，倒是存储解析都可以了，但是大大浪费了空间，utf-8这种实现就是一种灵活的可变字节数的编码，如果符号只用一个字节，那么存储就是一个，需要多个就多个。如何解析呢？利用第一个字节的前几位表示这个符合占用几个字节，这样解析的时候就知道这次是拿几个字节出来解码成对应的符号，大大利用了空间。）
编码过程：2条。1）单字节首位是0，其它7位是Unicode码。2）多字节，对于n字节的符号（n > 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。

```
字符  严     
Unicode   100    111000   100101
utf-8     111  0 (0100) 10 (111000) 10 (100101)    通过括号和空格分割，可以看道字符是如何从Unicode到utf-8的。
```

关于字节序：Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做"零宽度非换行空格"（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。

如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。

## 事件句柄

事件句柄又称为事件处理函数。它需要被赋值，比如将一个函数赋值给事件句柄。
当特定事件发生的时候，就去检查事件句柄有没有被赋值，如果有，则执行事件
句柄（执行该函数）

## 函数签名

函数的名称及其参数类型组合在一起，就定义了一个唯一的特性，称为函数签名。（不包括返回类型）

在编写包含函数调用的语句时，编译器就会使用该调用创建一个函数签名。再把它与函数原型/或定义中可用的函数签名集比较。如果找到匹配的函数名，就建立所调用的函数。(c++的解释)

函数签名对象，表示调用函数的方式，即定义了函数的输入和输出。在Python中，可以使用标准库inspect的一些方法或类，来操作或创建函数签名。

## 重载

多个相同函数名，不同的参数个数或者类型的形式叫做函数的重载。

## arp -a 

这个Windows命令中有一个类型的概念

类型：动态的是说过一定时间如果这个mac地址没有用到过，就会被删掉；静态的会被永久保留

## 可重入函数

可重入函数主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。

## ICMP

在IP通信中，经常有数据包到达不了对方的情况。原因是，在通信途中的某处的一个路由器由于不能处理所有的数据包，就将数据包一个一个丢弃了。或者，虽然到达了对方，但是由于搞错了端口号，服务器软件可能不能接受它。这时，在错误发生的现场，为了联络而飞过来的信鸽就是ICMP 报文。在IP 网络上，由于数据包被丢弃等原因，为了控制将必要的信息传递给发信方。ICMP 协议是为了辅助IP 协议，交换各种各样的控制信息而被制造出来的。

制定万维网规格的IETF 在1981 年将RFC7922作为ICMP 的基本规格整理出来了。那个RFC792 的开头部分里写着“ICMP 是IP 的不可缺少的部分，所有的IP 软件必须实现ICMP协议。也是，ICMP 是为了分担IP 一部分功能而被制定出来的。

## 前端概述

前端的发展到现在，我们引用人类文明发展历程做比喻，划分为4个时代，每一个时代都是技术的革命和进步，包括原始社会，石器时代，铁器时代，工业时代。

1. 原始社会

1994 年的时候，网景公司 (Netscape Communications) 推出了第一款浏览器：NCSAMosaic，当时还没有JavaScript语言，网页是静态的，基于HTML文本描述语言，提交一个表单，等待很久，最后可能返回给你个 “用户名错误”。

总结：这个时候是没有前端的概念的，页面是后端的一部分，也就是网页是由后端代码直接生成的。

2. 石器时代

就在同一年(1994 年)，PHP 出现了，有了将数据嵌入到 HTML 中的形式，这意味着互联网行业出现了钻木取火，不断朝石器时代发展。
这时候的互联网，兴起了数据嵌入模板，模板直接写样式的开发模式，发展成了后来的 MVC 模式：

Model（模型层）：提供/保存数据。
Controller（控制层）：数据处理，实现业务逻辑。
View（视图层）：展示数据，提供用户界面。

该模式至今仍在沿用，网页同样由后端生成，不过不是直接输出了，而是对模块的渲染，编写模板的工作已经属于前端的范畴了，不过由于模板和后端的绑定，编写模板需要了解后端，如现在的Django的模板语言，JSP技术等，此时仍然没有前端的地位，这些工作一般由后端开发人员完成，除非是比较复杂的页面布局，交由专门的人员编写。

总结: 技术开始规范，提出了MVC的开发模式。不过编写模板人员仍然需要了解后端模板语言，或者模板是静态的，写好后又由后端开发人员修改数据，工作重复和繁琐。

3. 铁器时代

- 3.1 JavaScript的诞生

1995年，网景工程师Brendan Eich花了10天时间设计了JavaScript语言。起初这种脚本语言叫做Mocha，后改名LiveScript，后来为了借助Java语言创造良好的营销效果最终改名为JavaScript。网景公司把这种脚本语言嵌入到了Navigator 2.0之中，使其能在浏览器中运行。这也是历史遗留问题的开端，Brendan Eich最初只是为了开发一种脚本语言，因而没有面向对象，也没有模块化等特性。

- 3.2 ECMA规范 

与此相对的是，1996年，微软发布了VBScript和JScript。JScript是对JavaScript进行逆向工程的实现，并内置于Internet Explorer 3中。但是JavaScript与JScript两种语言的实现存在差别，这导致了程序员开发的网页不能同时兼容Navigator和Internet Explorer浏览器。Internet Explorer开始抢夺Netscape的市场份额，这导致了第一次浏览器战争。

1996年11月，为了确保JavaScript的市场领导地位，网景将JavaScript提交到欧洲计算机制造商协会（European Computer Manufacturers Association）以便将其进行国际标准化。

1997年6月，ECMA以JavaScript语言为基础制定了ECMAScript标准规范ECMA-262。JavaScript是ECMAScript规范最著名的实现之一，除此之外，ActionScript和JScript也都是ECMAScript规范的实现语言。自此，浏览器厂商都开始逐步实现ECMAScript规范。

该规范一直沿用至今，我们经常听到的ES6, 全称 ECMAScript 6.0，是 JavaScript 的一个版本标准，2015.06 发布，增加了面向对象，模块化等支持，使得JavaScript 语言可以用来编写复杂的大型应用程序

- 3.3 动态网页

到了 1998 年前后，Ajax（Asynchronous Java And XML：异步的 Java 和 XML）得到了相对的应用，并且在之后逐渐被使用到各个页面上，从而促进了 Web 从 1.0 的静态网页，纯内容展示向 Web 2.0 模式迈进。

这时候，前端不再是后端的模板，它可以独立得到各种数据。相对于 Web 1.0 的时代，Web 2.0 由石器时代迈向了铁器时代！

在 Web 2.0 的时代中，在 2006 年的时候，用于操作 DOM 的 jQuery 出现了，它快速地风靡了全球。大量的基于 jQuery 的插件构成了一个庞大的生态系统，从而稳固了 jQuery 作为 JS 库一哥的地位。

jQuery 的影响是源远流长的，很少有人直接操作原生接口。

总结：JavaScript诞生，并由ECMA协会统一了规范和标准，避免了混乱的开端，ECMAScript是一个很重要的标准。提出了AJAX技术，网页从静态向动态发展。用于操作DOM的jQuery成为主流，降低了对DOM的操作难度。

4. 工业时代

伴随着信息时代、大数据时代的到来，jQuery 在大量的数据操作中的弊端体现出来了，它在对 DOM 进行大量的操作中，会导致页面的加载缓慢等问题（这也和DOM的设计，历史原因相关），这时，有些前端开发人员逐渐觉得力不从心了。

1999年，W3C发布了HTML 4.0.1版本，在之后的几年，没有再发布更新的Web标准。随着Web的迅猛发展，旧的Web标准已不能满足Web应用的快速增长，委员会开始起草新的web标准HTML5，2008年1月22日，第一份正式草案发布。
HTML5草案发布不久，Google在2008年12月发布了Chrome浏览器，加入了第二次浏览器大战当中。Chrome使用了Safari开源的WebKit作为布局引擎，并且研发了高效的JavaScript引擎V8。谷歌 V8 引擎发布，终结微软 IE 时代。

Chrome的发布，其JavaScript引擎V8的高效执行引起了Ryan Dahl的注意。2009年，Ryan利用Chrome的V8引擎打造了基于事件循环的异步I/O框架——Node.js诞生，谷歌也推出了自己的前端框架AngularJS，此后，2011 年 React 诞生。
2014 年 Vue.js 诞生。

新框架衍生出了新的MVVM开发模式

```
何为 MVVM 模式？
Model：提供/保存数据。
View：视图
View-Model：简化的 Controller，唯一的作用就是为 View 提供处理好的数据，不含其它逻辑。
```

如果说，Angular、React、Vue 等 MVVM 模式的出现，以及 Webpack 的前端工程化构建，加速了数据驱动前端工程化的发展。那么，Node 这个基于 V8 引擎的服务端 JavaScript 运行环境的诞生，可媲美 Ajax 对于前端的贡献。

Node 是前端的第二次飞跃，它使 JS 在服务端语言中也有了一席之地。

总结：前端开始飞速发展，百花齐放。三大框架Angular、React、Vue并立而行。至此，前端正式进入工业时代，开发更加工程化和规范化，JavaScript也不再是以往被人调侃的“玩具语言”，也不再局限于web开发，被运用于服务端，游戏，桌面，APP等。


### 当前主流

1. JavaScript的组成

我们回顾了前端的发展历程，提到了很多概念，我们常说的JavaScript是一种广义上的定义，它应该由三部分组成

JavaScript 分为 ECMAScript，DOM，BOM。

ECMAScript：在上文中已经多次提到了，它是欧洲计算机协会制定的标准，是一门程序设计语言，新版本中已经支持了许多特性，使得语言在项目开发中更加工程化，模块化。

DOM（文档对象模型）：DOM把整个HTML页面映射为一个多层节点结果，开发人员可借助DOM提供的API，轻松地删除、添加、替换或修改任何节点。

BOM（浏览器对象模型）：操作浏览器的API，比如页面刷新，跳转等。

理解了上面三点才是真正理解了JavaScript，ECMAScript是核心，只要有运行环境就可以被执行，而前端要依托于浏览器，DOM和BOM就是浏览器厂商来设计的，当然也会遵循一定的规范，有了这些接口我们才能实现丰富多彩的页面。


- 传统开发模式

在传统的前端开发模式中，一般就是围绕着html，js，css来展开，主页面是一个html页面，引入各种js依赖和css，当页面被浏览器加载的时候，整个页面被渲染完成，包含的js脚本完成各自的工作，主要就是对dom的事件绑定。
这种开发模式中，带来了很多问题

1. 首先就是js是单文件的，多个js的导入共享同一个命名空间，你可能会在代码中看到各种函数的调用，却不知道它到底在何处定义，越是复杂的项目这个问题就尤为突出。
2. DOM的操作过于繁琐，虽然有了jQuery，但是操作的本质还是没有变化，复杂一点的页面实现需要大量的html字符串拼接来实现，这种拼接极其晦涩难懂，而且性能上也会下降很多，造成这种情况的原因主要是对dom的理解不够深入，因为dom还是过于复杂，一般的应用编程完全不会涉及这么深的内容，应为当你了解到这个层次的时候，你可能已经可以开发一套完善的操作框架了。
3. 请求次数过于频繁，这也是传统开发模式的弊端。在ajax技术出现后，已经没有必要多次请求数据了，但是传统模式中，响应新页面要重新发起请求。请求过多，也就链接过多，对服务器处理造成一点负担。

- 新开发模式

以上问题在新开发模式中都被解决了

1. 新的ES标准，提供了模块化的支持，模块化是现代程序设计语言构建大型项目的基石，模块划分了命名空间
2. 基于新的ES标准所开发的Vue，React框架，拥有更加先进的DOM操作技术，多DOM的操作将变得极其简单
3. 通过webpack工具打包后，零散的文件将被整合，页面的跳转将转化为跟DOM节点的操作，这些操作都由浏览器来完成，页面只在第一次加载的时候请求资源，此后的所有操作都不再请求资源（接口数据除外），最大程度的降低了前端的请求次数，这种模式也被称为单页面应用(SPA)