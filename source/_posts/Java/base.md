---
title: Java编程思想
date: 2019-04-05 00:00:00
tags: [java, note]
categories: Java
---

Java 编程思想

<!-- more -->

## 名词解释

大部分都是通用的，或者是设计模式，只是第一次接触难免有些生疏晦涩。

构件：其实就是组件，可以按照组件来理解，不过在这个范畴内一般翻译为构件

DAO：数据库访问模型 Data Access Object

DTO：数据传输对象（DTO)(Data Transfer Object)，是一种设计模式之间传输数据的软件应用系统。数据传输目标往往是数据访问对象从数据库中检索数据。数据传输对象与数据交互对象或数据访问对象之间的差异是一个以不具有任何行为除了存储和检索的数据（访问和存取器）。

Bean：它的定义为，描述Java的软件组件模型，EJB是Enterprise Java Bean的缩写。javaBean在MVC设计模型中是model，又称模型层，在一般的程序中，我们称它为数据层，就是用来设置数据的属性和一些行为，然后我会提供获取属性和设置属性的get/set方法JavaBean是一种JAVA语言写成的可重用组件。

JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序，同时，JDBC也是个商标名。

JPA是Java Persistence API的简称，中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。
Sun引入新的JPA ORM规范出于两个原因：其一，简化现有Java EE和Java SE应用开发工作；其二，Sun希望整合ORM技术，实现天下归一。

JNDI(Java Naming and Directory Interface,Java命名和目录接口)是SUN公司提供的一种标准的Java命名系统接口，JNDI提供统一的客户端API，通过不同的访问提供者接口JNDI服务供应接口(SPI)的实现，由管理者将JNDI API映射为特定的命名服务和目录系统，使得Java应用程序可以和这些命名服务和目录服务之间进行交互。

## 环境变量

配置环境变量，保证 java javac java -version 都能输出正确信息

## 1 基本内容

return 只能返回一个对象，python可以返回多个，面向对象体现更明显，强类型

面向对象部分是Java核心和难点部分，不过语言还是要在实践中学习，而实践又会用框架，等代码感熟练了，慢慢的去看源码的时候，再来体会面向对象更容易掌握，初期可以跳过繁琐的概念，因为看了也记不住。

面向对象集中在7，8，9，10章节，以其它语言的基础可以快速过一遍，先理解11章后的内容

## 2 一切都是对象

对象成员不进行初始化会设定默认值，不过对于局部变量不适应。

面向对象：字段或数据成员，方法，Python中叫做属性。

方法签名，可能在Python中不怎么提及这个概念，由于Java是静态语言，所以方法签名唯一确定方法。

java.lang 是一个类库，每个Java文件都会默认导入它。

main() 方法的参数是一个String对象的数组，以及一个args，一般都要写这两个，否则编译器报错，因为args要用来存储命令行参数。

注释文档：javadoc是JDK安装的一部分，用于提取注释的工具。该工具提取注释，可以生产html文件。可以对工具输出风格做调整，通过编写自己的被称为 “doclets” 的javadoc处理器来实现。javadoc 有特定的语法。

所有的javadoc语法只能在 “/**  */” 注释中出现，“//” 是不可以的。

使用方式：嵌入HTML，使用文档标签。

栈内存：是一种连续储存的数据结构，具有先进后出的性质。
通常的操作有入栈（压栈），出栈和栈顶元素。想要读取栈中的某个元素，就是将其之间的所有元素出栈才能完成

堆内存：是一种非连续的树形储存数据结构，每个节点有一个值，整棵树是经过排序的。特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。常用来实现优先队列，存取随意。

1. 栈：为编译器自动分配和释放，如函数参数、局部变量、临时变量等等
2. 堆：为成员分配和释放，由程序员自己申请、自己释放。否则发生内存泄露。典型为使用new申请的堆内容。
除了这两部分，还有一部分是：
3. 静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。

## 3 操作符

别名对象, 可以强制类型转换
equals()
直接常量可以添加标识符，使表达更加清晰
类型转换操作符 long i = (long) j  将整形j转换成长整形并赋值给i，转换总是截尾，要想四舍五入需要使用round库
提升：对基本类型执行按位运算或算术运算，只要类型比int小（比如char,byte,short），那么在运算之前，会自动转换成int。较大的数据类型决定了结果，比如double和float相乘，结果是double
sizeof：c,c++中用来计算数据占的字节，这导致移植代码很头疼，不同的处理器对数据存储所占的字节是不一样的，而Java不会这样，它的数据类型在所有机器上都是一样的

## 4 控制执行流程

不允许将一个数字作为布尔值使用，应该if(a==0)，for循环语法，for(int i : range(100))

## 5 初始化与清理

构造器：构造器的命名和类名相同，可以带访问修饰符，不能有返回值。

方法重载：构造器也可以方法重载，方法重载要求函数名相同，参数不一样，参数的顺序不一样也是方法重载，但是一般不建议这么做。一般动态语言不需要方法重载。方法重载一定要写的明确，这样编译器在调用方法的时候才知道是调用哪个方法。

缺省构造器：构造器可以不提供，编译器默认创建一个，这个时候构造器没做任何事情

this关键字：通常不需要显示的写出它来，和python不一样，另外它是关键字

垃圾回收：
1.对象可能不被垃圾回收 2.垃圾回收并不等于析构

## 6 访问控制

java后缀的源代码通常称为编译单元，每个编译单元内只能有一个public类。

代码组织：当编译一个java后缀文件时，文件的每个类都会生成.class文件。

关于package语句，必须是文件中除注释外的第一句代码。包命名规则全部使用小写字母，包括中间的字也是如此。导包用的星号如果两个包包含同一个类，那么这肯定是有问题的，但是只要不写调用的代码编译器是不会报错的，这种情况应该用完整路径来引用对象。

理解编译单元，默认包，friendly权限是java的默认权限，也称作包（package）访问权限

public private

1. 默认包：同一个包下的两个类，可以做到A类访问B类的未修饰方法，如果C类和A类不属于同一个包，那么C类的方法要修饰为public，A类才能访问到。这种默认的机制保护了包下的类，但是最好做修饰，在IDEA中，你不对类的方法做修饰，会有告警级别的提示，因为默认的包访问权限可以方便包，对不属于同一个包的访问做保护，但是最好考虑清楚，然后合理运用private。

2. 另外即使使用了private修饰，仍然可以在当前类定义新的方法去访问private，所有不能因为在类中某个对象的引用是private，就认为其他的对象无法拥有该对象的public引用

protected: 受保护的

一个类继承了另一个包中的类，那么唯一可访问的成员就是源包的public成员。（如果继承在同一个包中，就可以访问所有的拥有包访问权限的成员）。基类的创建者希望某个成员，把他的访问权限给予派生类而不是所有类，这时候就可以使用protected，protected也提供包访问权限，同意包内的其它类可以访问protected元素。这是为了在拥有包访问权限下，为了让跨包继承类也能访问的一种做法，否则就要用public来修饰。

`访问权限的控制常被称为是具体实现的隐藏`

类的访问权限：一个包下的类，要遵守他的文件名定义规则，然后只能有一个public类，可以把public去掉，这样该类就只有包访问权限，其它包即使导入他，也不能访问，通过也很少这么做。另外当不用public修饰类时，类命可以不和文件名一致。

再次强调，类前面不加修饰，权限就是包访问权限，当前包内的其它类可以访问，跨包不行。

## 7 复用类

组合，继承，代理

每一个非基本类型对象都有一个toString方法，类似python的 `__str__`

初始化，继承的基类初始化的时候，默认会调用基类的构造方法，构建过程是从基类“向外”扩散的，当然这只能调用默认不带参数的构造器，带参数的构造器需要显示的调用super方法。

```java
class Cleanser {
    Cleanser(int i) {
        System.out.println(i);
    }
    Cleanser() {
        System.out.println("123");
    }
}

public class Detergent extends Cleanser {
    Detergent() {
        // super(321)
        System.out.println("abc");
    }
    public static void main(String[] args) {
        Detergent x = new Detergent();
        System.out.println("Testing base class");
    }
}
```

如果去掉Cleanser类的默认构造函数，IDEA会警告，因为找不到满足条件的构造函数，编译代码会去调用需要传递参数的构造函数导致报错。注释部分为显示调用。

名称屏蔽：如果Java的基类拥有某个已被多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽在基类中的任何版本，这一点与C++不同`（如果C++要这么做需要屏蔽基类方法，另外本书比较旧了，不排除c++做了改动）`

```java
class Homer {
    char doh(char c) {
        System.out.println("doh(char)");
        return 'd';
    }

    float doh(float f) {
        System.out.println("doh(float)");
        return 1.0f;
    }
}

class Milhouse {
}

class Bart extends Homer {
    void doh(Milhouse m) {
        System.out.println("doh(Milhouse)");
    }
}

public class Hide {
    public static void main(String[] args) {
        Bart b = new Bart();
        b.doh(1);
        b.doh('x');
        b.doh(1.0f);
        b.doh(new Milhouse());
    }
}
// doh(float)
// doh(char)
// doh(float)
// doh(Milhouse)
```

向上转型：基类A，有一个方法，参数类型为A的引用，导出类B，调用A的方法，传递参数为B的实例，这似乎和强类型语言Java违背，但在继承中是可以的，你需要认识到B对象同样也是一种A对象，这种将B的引用转换为A的引用的动作，称为向上转型。父类引用变量可以引用子类对象。

final:

1. 允许空白final，但是在构造函数中必须进行初始化。
2. final 参数，可以用来修饰参数。被修饰的参数不能在方法中去修改它。
3. 修饰方法，防止方法被继承类修改。
4. 类修饰，那么该类无法被继承。类方法都会隐式的指向final。

private 和 final: 类中的private方法都隐式的指定为final。可以对private添加final，但这并不能给该方法增加任何额外的意义。 “覆盖”只有在某方法是基类的接口的一部分才会出现，即`必须能将一个对象向上转型`为它的基本类型并调用相同的方法。如果某方法为private，它就不是基类接口的一部分，用private修饰的方法在基类中同名方法不是方法覆盖，而是生成一个新的方法。

static、final、static final的区别(转自：http://blog.csdn.net/qq1623267754/article/details/36190715)

1. final 
 
final类不能被继承，没有子类，final类中的方法默认是final的
final方法不能被子类的方法复盖，但可以被继承
final成员变量表示常量，只能被赋值一次，赋值后不能再被改变
final不能用于修饰构造方法
private不能被子类方法覆盖，private类型的方法默认是final类型的

final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。
注意：final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。

2. static
 
static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，也可以形成静态static代码块，但是Java语言中没有全局变量的概念。
 
被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它不依赖类特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。
 
用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象市，不生成static变量的副本，而是类的所有实例共享同一个static变量。
 
- 类成员变量
  - 静态变量（类变量）: static修饰
  - 实例变量      : 无static修饰
- 局部变量
 
 
3. static和final一起使用
 
static final用来修饰成员变量和成员方法，可以理解为“全局变量”
 
对于变量，表示一旦给值就不可修改，并且通过类名可以访问。
对于方法，表示不可覆盖，并且可以通过类名直接访问。
 
注意：
对于被static和final修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象。

`继承与初始化`

```java
class Insect {
    private int i = 9;
    protected int j;
    Insect() {
        System.out.println("i = " + i + ", j= " + j);
        j = 39;
    }
    private static int x1 = printInt("static Insecr.x1 initialized");
    static int printInt(String s) {
        System.out.println(s);
        return 47;
    }
}

public class Beetle extends Insect {
    private int k = printInt("Beetle.k initialized");
    public Beetle () {
        System.out.println("k = " + k);
        System.out.println("j = " + j);
    }
    private static int x2 = printInt("static Beetle.x2 initialized");
    public static void main(String[] args) {
        System.out.println("Beetle constructor");
        Beetle b = new Beetle();
    }
}
//static Insecr.x1 initialized
//static Beetle.x2 initialized
//Beetle constructor
//i = 9, j= 0
//Beetle.k initialized
//k = 47
//j = 39
```

理解以上输出结果。

1. 每个类的编译代码都存在于它自己的独立文件夹中。
2. 该文件只在需要使用程序代码时才会被加载。
3. 一般来说类的代码在初次使用时才会加载，这通常指加载发生于创建类的第一个对象之时（但是访问static域或static方法时，也会加载。构造器也是static方法，它没有显示的表示出来，更准确的说，类是在其任何static成员被访问时才加载的）
4. 按照继承先加载对象，继承最顶层的类先被加载，然后是下面的类。然后创建对象，基本类型设置为默认值，对象的引用设置为null（通常是将对象内存二进制设置为零），然后是构造器调用。

## 8 多态

Polymoph 多态

在面向对象程序设计语言中，多态是继数据抽象和继承之后的第三种基本特征。

“封装”通过合并特征和行为来创建新的数据类型。“实现隐藏”则通过将细节“私有化”把接口和实现分离开来。多态的作用是消除类型之间的耦合关系。

方法调用绑定：在程序执行前就把方法同相关联的方法主体关联起来称为前期绑定，与之相对的就是后期绑定，就是在运行时根据对象类型进行绑定。所有编译器需要有一种机制在运行时判断对象类型。Java除了static和final（private也是final）之外，其它都是后期绑定。使用final就可以告诉编译器关系动态绑定，一定程度优化代码，不过完全没有这个必要。
Java中的所有方法都是通过动态绑定来实现多态的。

需要注意私有方法，确定你是要覆盖还是重载。

多态存在的三个必要条件
1. 继承
2. 重写
3. 父类引用指向子类对象

当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。

协变返回类型: 在Java1.4及以前，子类方法如果要覆盖超类的某个方法，必须具有完全相同的方法签名，包括返回值也必须完全一样。Java5.0放宽了这一限制，只要子类方法与超类方法具有相同的方法签名，或者子类方法的返回值是超类方法的子类型，就可以覆盖。

"协变返回(covariant return)"，仅在subclass（子类）的返回类型是superclass（父类）返回类型的extension（继承）时才被容许。

{% blockquote %}
方法是放在代码区(code seg)里面的，里面的方法就是一句句代码。
因此当使用pet引用去访问父类对象的方法时，首先是找到这个父类对象，然后看看它里面的方法到底在哪里存着，找到那个方法再去执行。
这里头就比较有意思了，code seg里面有很多个enjoy方法，有父类的enjoy()方法，也有子类重写了从父类继续下来的enjoy()方法，那么调用的时候到底调用的是哪一个呢？是根据谁来确定呢？

注意：这是根据你实际当中的对象来确定的，你实际当中new出来的是谁，就调用谁的enjoy方法，当你找这个方法的时候，通过pet引用能找得到这个方法，但调用代码区里面的哪一个enjoy方法不是通过引用类型来确定的，如果是通过引用类型pet来确定，那么调用的肯定是Animal的enjoy()方法，可是现在是根据实际的类型来确定，我们的程序运行以后才在堆内存里面创建出一只Cat，然后根据你实际当中new出来的类型来判断我到底应该调用哪一个enjoy()方法。如果是根据实际类型，那么调用的就应该是Cat的enjoy()方法。如果是根据引用类型，那么调用的就应该是Animal的enjoy()方法。

现在动态绑定这种机制指的是实际当中new的是什么类型，就调用谁的enjoy方法。所以说虽然你是根据我父类里面的enjoy方法来调用，可是实际当中却是你new的是谁调用的就是谁的enjoy()方法。

即实际当中调用的却是子类里面重写后的那个enjoy方法。

当然，讲一点更深的机制，你实际当中找这个enjoy方法的时候，在父类对象的内部有一个enjoy方法的指针，指针指向代码区里面父类的Animal的enjoy方法，只不过当你new这个对象的时候，这个指针随之改变，你new的是什么对象，这个指针就指向这个对象重写后的那个enjoy方法，所以这就叫做动态绑定。
只有在动起来的时候，也就是在程序运行期间，new出了这个对象了以后你才能确定到底要调用哪一个方法。我实际当中的地址才会绑定到相应的方法的地址上面，所以叫动态绑定。
调这个方法的时候，只要你这个方法重写了，实际当中调哪一个，要看你实际当中new的是哪个对象，这就叫多态，也叫动态绑定。

动态绑定带来莫大的好处是使程序的可扩展性达到了最好，我们原来做这个可扩展性的时候，首先都是要在方法里面判断一下这只动物是哪一类里面的动物，通过if (object instanceof class)这样的条件来判断这个new出来的对象到底是属于哪一个类里面的，如果是一只猫，就调用猫的enjoy方法，如果是一条狗，就调用狗的enjoy方法。

如果我现在增加了一个Bird类，那么扩展的时候，你又得在方法里面写判断这只鸟属于哪一个类然后才能调用这只鸟的enjoy方法。每增加一个对象，你都要在方法里面增加一段判断这个对象到底属于哪个类里面的代码然后才能执行这个对象相应的方法。

即每增加一个新的对象，都要改变方法里面的处理代码，而现在，你不需要再改变方法里面的处理代码了，因为有了动态绑定。

你要增加哪一个对象，你实际当中把这个对象new出来就完了，不再用去修改对象的处理方法里面的代码了。也就是当你实际当中要增加别的东西的时候，很简单，你直接加上去就成了，不用去改原来的结构，你要在你们家大楼的旁边盖一个厨房，很简单，直接在旁边一盖就行了，大楼的主要支柱什么的你都不用动，这就可以让可扩展性达到了极致，这就为将来的可扩展打下了基础，也只有动态绑定（多态）这种机制能帮助我们做到这一点——让程序的可扩展性达到极致。因此动态绑定是面向对象的核心，如果没有动态绑定，那么面向对象绝对不可能发展得像现在这么流行，所以动态绑定是面向对象核心中的核心。

总结动态绑定（多态）：动态绑定是指在“执行期间”（而非编译期间）判断所引用的实际对象类型，根据其实际的类型调用其相应的方法。所以实际当中找要调用的方法时是动态的去找的，new的是谁就找谁的方法，这就叫动态绑定。动态绑定帮助我们的程序的可扩展性达到了极致。

虽然及其的啰嗦，这也是先入为主的影响吧，如果你先学的python，你会觉得这是理所当然的。
{% endblockquote %}

## 9 接口

接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法

抽象类或抽象方法：abstract定义抽象方法，如果一个类包含一个抽象方法，必须修饰为抽象类。在C++中，这相当于虚函数，纯虚函数。

接口使得抽象的概念更向前迈进了一步，接口产生一个完全抽象的类，允许创建者确定方法名，列表参数，返回类型，不提供方法体。

接口中的方法默认是public的，接口类默认是包访问权限。

通过关键字implements(实现)来像继承一样声明当前类是哪个接口的实现。

```java
interface B {

}
interface A extends B {

}
// 接口继承
```

```java
class A implements B
// 普通的实现
```

```java
class A implements B, C, D
// 实现来自多个接口
```

```java
class A extends B implements C, D {}
// 实现了多继承，也避免了钻石继承问题
```

接口适配：允许一个接口有多个不同的实现

接口的域：由于接口的任何域都是final和static，历史代码会用接口来做常量，Java SE5 后，一般用枚举enum来代替了

嵌套接口：接口可以嵌套在类中，可能这种运用有点少见，要知道可以这么做，遇到了可以来看看书

## 10 内部类

将一个类的定义放在另一个类的定义中，称为内部类（暂时跳过这一章节）

this的常见用法：调用构造器，直接this()。调用方法，指代当前调用对象。由于大括号内封闭作用域，如果形参定义了和对象成员同名的属性，直接使用该名称无法取到对象成员，此时应该用this关键字。


## 11 持有对象

该章节设计到很多设计模式，体会其中的思想

容器类：基本类型是List，set，Queue和Map，这些对象类型也称为集合类，但由于Java的类库使用了Collection这个名字来指代该类库的一个特殊子集，所有更广泛的称为容器

Map：也被称为关联数组

List：基本的ArrayList，它长于随机访问元素，但是在List的中间插入和移除元素时较慢。LinkedList，它通过代价较低的在List中间进行的插入和删除操作，提供了优化的顺序访问，在随机访问较慢，占空间也大。

迭代器：对容器的访问

Collection 是描述所有序列容器的共性的根接口

Foreach 也可以用于任何Collection对象

容器不能持有基本类型，但是自动包装机制会仔细地执行基本类型到容器中所持有的包装器类型之间的双向转换

大量的随机访问，使用ArrayList，经常从中间插入或删除元素使用LinkedList，各种Queue以及栈的行为，由LinkedList提供支持

关于Map，HashMap用于快速访问，TreeMap始终让键保持在排序状态(类似二叉树插入)，LinkedHashMap保持插入顺序，也提供散列提供快速访问的能力

## 12 异常

一个异常的例子：throw new NullPointerException("abc")

异常根类 Throwable

try 处理块：

```java
try {

} catch (Exception e) {

} catch (Exception2 e) {

}
```

## 13 字符串

## 14 类型信息

`本章重点，class后缀文件，和类加载器`

RTTI：运行时类型识别

Class对象，它是一个特殊的对象，每当编译一个新类就会产生其同名的Class对象，后缀名是Class，也就是字节码。为了生成这个类对象，运行这个程序的JVM将使用被称为“类加载器的”子系统。该部分都是运行时涉及到的概念。
所以的类对象都是在对其第一次使用的时候，动态的加载到JVM中的。使用new关键字创建类的新对象被当作对类的静态成员的引用。


## 15 泛型

泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。

Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。

## 20 注解

包含三种标准注解和四种元注解

标准注解：
1. Override
2. Deprecated
3. SuppressWarnings

元注解：
1. Target
2. Retention
3. Documented
4. Inherited

注解是一种标记，基本注解用来决定注解到什么地方，什么时候发挥作用。我们需要读取注解的工具，也就是`创建与使用注解处理器`

注解处理器是一个单独的类，通过获取被注解的类，然后调用获取注解信息的方法得到注解信息，之后进行操作。有各种反射方法来获取注解标记的信息。

